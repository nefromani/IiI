-- ===== –ë–´–°–¢–†–ê–Ø –ü–†–û–í–ï–†–ö–ê HWID –ë–ï–ó –ó–ê–î–ï–†–ñ–ï–ö =====334
-- –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –∫–ª—é—á —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω
if not _G.SCRIPT_KEY then
    game.Players.LocalPlayer:Kick("‚ùå –£–∫–∞–∂–∏—Ç–µ _G.SCRIPT_KEY –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º!")
    return
end

local MY_HWID = _G.SCRIPT_KEY
local LOCAL_NODE_HWID_URL = "http://127.0.0.1:51949/hwid"

local function http_get(url)
    if syn and syn.request then
        local ok, res = pcall(function() return syn.request({Method = "GET", Url = url}) end)
        if ok and res and res.Body then return res.Body end
    end
    if game and game.HttpGet then
        local ok, res = pcall(function() return game:HttpGet(url, true) end)
        if ok and res then return res end
    end
    return nil
end

print("üîê –ü—Ä–æ–≤–µ—Ä–∫–∞ HWID...")

-- –ë–´–°–¢–†–ê–Ø –ø—Ä–æ–≤–µ—Ä–∫–∞ HWID
local server_hwid = (http_get(LOCAL_NODE_HWID_URL) or ""):gsub("%s+","")

if server_hwid == "" then
    game.Players.LocalPlayer:Kick("‚ùå Python —Å–µ—Ä–≤–µ—Ä –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç!")
    return
end

if server_hwid ~= MY_HWID then
    game.Players.LocalPlayer:Kick("‚ùå HWID –Ω–µ —Å–æ–≤–ø–∞–¥–∞–µ—Ç!\n–°–µ—Ä–≤–µ—Ä: " .. server_hwid)
    return
end

print("‚úÖ HWID –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ–π–¥–µ–Ω–∞!")

-- ===== –£–õ–£–ß–®–ï–ù–ù–ê–Ø –°–ò–°–¢–ï–ú–ê –ó–ê–ì–†–£–ó–ö–ò =====
-- ===== –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –°–ò–°–¢–ï–ú–ê –ó–ê–ì–†–£–ó–ö–ò =====
local function waitForFullLoad()
    print("[Loading] Waiting for game to fully load...")
    
    -- –®–∞–≥ 1: –ë–∞–∑–æ–≤–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –∏–≥—Ä—ã
    if not game:IsLoaded() then
        game.Loaded:Wait()
        print("[Loading] Game basic loading complete")
    end
    
    -- –®–∞–≥ 2: –ñ–¥–µ–º RunService
    local RunService = game:GetService("RunService")
    for i = 1, 10 do
        RunService.Heartbeat:Wait()
    end
    print("[Loading] RunService ready")
    
    -- –®–∞–≥ 3: –ë–ï–ó–û–ü–ê–°–ù–û –∂–¥–µ–º Player –ø–æ–ª–Ω–æ—Å—Ç—å—é –∑–∞–≥—Ä—É–∂–µ–Ω
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    
    -- –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –æ–∂–∏–¥–∞–Ω–∏–µ LocalPlayer
    while not LocalPlayer do
        wait(1)
        LocalPlayer = Players.LocalPlayer
        print("[Loading] Waiting for LocalPlayer...")
    end
    print("[Loading] LocalPlayer ready")
    
    -- –®–∞–≥ 4: –ë–ï–ó–û–ü–ê–°–ù–û –∂–¥–µ–º PlayerGui
    while not LocalPlayer:FindFirstChild("PlayerGui") do
        wait(1)
        print("[Loading] Waiting for PlayerGui...")
    end
    print("[Loading] PlayerGui ready")
    
    -- –®–∞–≥ 5: –ü—Ä–æ–≤–µ—Ä—è–µ–º CoreGui –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ä–∞–∑
    local CoreGui
    for attempt = 1, 10 do
        local success, result = pcall(function()
            return game:GetService("CoreGui")
        end)
        
        if success and result then
            CoreGui = result
            -- –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —á—Ç–æ CoreGui —Ä–µ–∞–ª—å–Ω–æ —Ä–∞–±–æ—Ç–∞–µ—Ç
            local testSuccess = pcall(function()
                local testGui = Instance.new("ScreenGui")
                testGui.Parent = CoreGui
                testGui:Destroy()
            end)
            
            if testSuccess then
                print("[Loading] CoreGui ready and functional")
                break
            end
        end
        
        print("[Loading] CoreGui attempt " .. attempt .. "/10...")
        wait(0.5)
    end
    
    if not CoreGui then
        error("Failed to get CoreGui after 10 attempts!")
    end
    
    -- –®–∞–≥ 6: –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è –ø–æ–ª–Ω–æ–π —Å—Ç–∞–±–∏–ª–∏–∑–∞—Ü–∏–∏
    print("[Loading] Final stabilization wait...")
    wait(2)
    
    -- –®–∞–≥ 7: –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –Ω–µ—Ç –¥—Ä—É–≥–∏—Ö –∫–æ–Ω—Ñ–ª–∏–∫—Ç—É—é—â–∏—Ö GUI
    local existingGUI = CoreGui:FindFirstChild("AUFJoinerUI")
    if existingGUI then
        print("[Loading] Removing existing GUI...")
        existingGUI:Destroy()
        wait(0.5)
    end
    
    print("[Loading] ‚úÖ All systems ready for UI creation!")
    return CoreGui
end

-- ===== –¢–í–û–ô –û–°–ù–û–í–ù–û–ô –°–ö–†–ò–ü–¢ =====
-- –ó–ê–©–ò–¢–ê –û–¢ –û–®–ò–ë–û–ö ZENIT
local function safeWaitForChild(parent, childName, timeout)
    timeout = timeout or 10
    local start = tick()
    while tick() - start < timeout do
        if parent and parent.FindFirstChild then
            local child = parent:FindFirstChild(childName)
            if child then
                return child
            end
        end
        task.wait(0.1)
    end
    return nil
end

-- –ë–ï–ó–û–ü–ê–°–ù–ê–Ø –∑–∞–≥—Ä—É–∑–∫–∞
if not game:IsLoaded() then
    game.Loaded:Wait()
end

local Players = game:GetService("Players")
local player = Players.LocalPlayer
while not player do
    task.wait(0.5)
    player = Players.LocalPlayer
end

local WebSocketURL = "ws://127.0.0.1:51948"

local function prints(str)
    print("[AUFJoiner]: " .. str)
end

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local VIM = (pcall(function() return game:GetService("VirtualInputManager") end) and game:GetService("VirtualInputManager")) or nil
local CoreGui = game:GetService("CoreGui")
local playerGui = player.PlayerGui

-- === –£–º–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º –≤—ã–±–æ—Ä–∞ === --
local function calculateScore(players, money)
    local currentPlayers = tonumber(players:match("(%d+)/")) or 8
    local freeSlots = 8 - currentPlayers
    local moneyValue = tonumber(money:match("%d+")) or 0
    
    if freeSlots >= 5 then
        return freeSlots * 2000000 + moneyValue * 500
    elseif freeSlots >= 3 then
        return freeSlots * 1500000 + moneyValue * 1000
    else
        return freeSlots * 500000 + moneyValue * 2000
    end
end

local isActive = false
local ws = nil
local connection = nil
local menuGui, hopperButton, lockButton, logText, discordLabel, spammerButton
local jobQueue = {}
local jobsByName = {}
local currentBestJob = nil
local isProcessing = false
local lastProcessedJob = nil
local isUILocked = true

-- ===== SPAMMER =====
local isSpammerActive = false
local spamCooldown = 5 -- —Å–µ–∫—É–Ω–¥ –º–µ–∂–¥—É –ø–æ–ø—ã—Ç–∫–∞–º–∏ —Å–ø–∞–º–∞
local lastSpamJob = nil
local lastSpamTime = 0

local function addLog(message)
    if not logText then return end
    logText.Text = "‚Üí " .. message
end

-- –§—É–Ω–∫—Ü–∏–∏ –∏–∑ —Ä–∞–±–æ—á–µ–≥–æ —Å–∫—Ä–∏–ø—Ç–∞ –¥–ª—è HirimiGui
-- –ë–ï–ó–û–ü–ê–°–ù–ê–Ø —Ñ—É–Ω–∫—Ü–∏—è –ø–æ–∏—Å–∫–∞ HirimiGui
local function findHirimiGui()
    -- –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –æ–∂–∏–¥–∞–Ω–∏–µ PlayerGui
    local playerGui = safeWaitForChild(player, "PlayerGui")
    if not playerGui then 
        print("‚ùå PlayerGui not found after waiting")
        return nil 
    end
    
    -- –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –æ–∂–∏–¥–∞–Ω–∏–µ HirimiGui
    local hirimiGui = safeWaitForChild(playerGui, "HirimiGui")
    if not hirimiGui then
        print("‚ùå HirimiGui not found in PlayerGui")
        return nil
    end
    
    return hirimiGui
end

local function findJobIDTextBox(gui)
    if not gui then return nil end
    
    for _, d in ipairs(gui:GetDescendants()) do
        if d and d:IsA("TextLabel") and d.Text == "Job-ID Input" then
            local parent = d.Parent
            if parent then
                for _, child in ipairs(parent:GetChildren()) do
                    if child and child:IsA("Frame") then
                        local tb = child:FindFirstChildOfClass("TextBox")
                        if tb then return tb end
                    end
                end
            end
        end
    end
end

-- –ë–ï–ó–û–ü–ê–°–ù–ê–Ø –≤—Å—Ç–∞–≤–∫–∞ JobID
local function setJobIDText(targetGui, text)
    if not targetGui then 
        print("‚ùå targetGui is nil in setJobIDText")
        return false 
    end

    local textBox = findJobIDTextBox(targetGui)
    if not textBox then 
        print("‚ùå TextBox not found")
        return false 
    end

    textBox:CaptureFocus()
    task.wait(0.001)
    textBox.Text = text
    task.wait(0.001)
    textBox:ReleaseFocus()
    print("[+] JobID –≤—Å—Ç–∞–≤–ª–µ–Ω: " .. text)
    return true
end

local function findJoinButton(gui)
    if not gui then return nil end
    
    for _, d in ipairs(gui:GetDescendants()) do
        if d:IsA("TextLabel") and d.Text == "Join Job-ID" then
            local parent = d.Parent
            for _, child in ipairs(parent:GetChildren()) do
                if child:IsA("TextButton") then
                    return child
                end
            end
        end
    end
end

local function fireFirstConnectionOfSignal(sig)
    if type(sig) ~= "userdata" then return false end
    local ok_get, _ = pcall(function() return getconnections end)
    if not ok_get then return false end
    local ok, conns = pcall(function() return getconnections(sig) end)
    if not ok or not conns or #conns == 0 then return false end
    local success, _ = pcall(function() conns[1]:Fire() end)
    return success
end

local function clickJoinButton(targetGui)
    local button = findJoinButton(targetGui)
    if not button then return false end
    
    if button.Activated then
        local ok = fireFirstConnectionOfSignal(button.Activated)
        if ok then
            print("[+] –ö–Ω–æ–ø–∫–∞ Join –Ω–∞–∂–∞—Ç–∞ (fire first Activated connection)")
            return true
        end
    end
    
    -- fallback VirtualInputManager –∫–ª–∏–∫
    if VIM then
        local absPos = button.AbsolutePosition
        local absSize = button.AbsoluteSize
        local x = absPos.X + absSize.X/2
        local y = absPos.Y + absSize.Y/2
        VIM:SendMouseButtonEvent(x, y, 0, true, game, 1)
        task.wait(0.01)
        VIM:SendMouseButtonEvent(x, y, 0, false, game, 1)
        print("[~] –ö–Ω–æ–ø–∫–∞ Join –Ω–∞–∂–∞—Ç–∞ —á–µ—Ä–µ–∑ VIM fallback")
        return true
    end
    
    return false
end

-- –ë—ã—Å—Ç—Ä–∞—è –±–∏–Ω–∞—Ä–Ω–∞—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞
local function insertSorted(jobData)
    if #jobQueue == 0 then
        table.insert(jobQueue, jobData)
        return
    end
    
    local left, right = 1, #jobQueue + 1
    while left < right do
        local mid = math.floor((left + right) / 2)
        if jobQueue[mid].score > jobData.score then
            left = mid + 1
        else
            right = mid
        end
    end
    table.insert(jobQueue, left, jobData)
end

-- –í —Ñ—É–Ω–∫—Ü–∏–∏ addJob (–≥–¥–µ –¥–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–π —Å–µ—Ä–≤–µ—Ä) –¥–æ–±–∞–≤–ª—è–µ–º —Å–±—Ä–æ—Å —Å–ø–∞–º–µ—Ä–∞:
local function addJob(jobData)
    if jobsByName[jobData.name] then
        for i, v in ipairs(jobQueue) do
            if v.name == jobData.name then
                table.remove(jobQueue, i)
                break
            end
        end
    end

    insertSorted(jobData)
    jobsByName[jobData.name] = jobData

    -- –°–ë–†–ê–°–´–í–ê–ï–ú –°–ü–ê–ú–ï–† –ö–û–ì–î–ê –ü–†–ò–•–û–î–ò–¢ –ù–û–í–´–ô –°–ï–†–í–ï–†
    if isSpammerActive then
        lastSpamJob = jobData.jobId  -- –û–±–Ω–æ–≤–ª—è–µ–º –Ω–∞ –Ω–æ–≤—ã–π JobID
        lastSpamTime = 0  -- –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ç–∞–π–º–µ—Ä —á—Ç–æ–±—ã —Å—Ä–∞–∑—É –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å
        addLog("üîÑ Spammer: switched to new job")
    end

    while #jobQueue > 10 do
        local removed = table.remove(jobQueue)
        jobsByName[removed.name] = nil
    end
end

-- –£–°–ö–û–†–ï–ù–ù–ê–Ø –æ–±—Ä–∞–±–æ—Ç–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞
local function processBestJob()
    if not currentBestJob or isProcessing then return end
    isProcessing = true

    local job = currentBestJob
    local targetGui = findHirimiGui()
    if not targetGui then
        addLog("‚ùå HirimiGui –Ω–µ –Ω–∞–π–¥–µ–Ω")
        isProcessing = false
        return
    end

    -- –í—Å—Ç–∞–≤–∫–∞ JobID
    local success = setJobIDText(targetGui, job.jobId)
    if not success then
        addLog("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –≤—Å—Ç–∞–≤–∏—Ç—å JobID")
        isProcessing = false
        return
    end

    task.wait(0.01) -- –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞

    -- –ù–∞–∂–∞—Ç–∏–µ –∫–Ω–æ–ø–∫–∏ Join
    if not clickJoinButton(targetGui) then
        addLog("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–∂–∞—Ç—å Join")
        isProcessing = false
        return
    end

    addLog("‚úÖ Joined: "..job.name.." | "..job.players.." | "..job.money.."/sec")
    
    -- –ó–∞–ø–æ–º–∏–Ω–∞–µ–º –¥–ª—è —Å–ø–∞–º–µ—Ä–∞
    lastSpamJob = job.jobId
    lastSpamTime = tick()
    
    isProcessing = false
end

-- –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –æ–±—Ä–∞–±–æ—Ç–∫–∏
-- –í —Ñ—É–Ω–∫—Ü–∏–∏ processingLoop:
local function processingLoop()
    while true do
        if isActive and #jobQueue > 0 and not isProcessing then
            currentBestJob = jobQueue[1]
            
            -- –û–ë–ù–û–í–õ–Ø–ï–ú –°–ü–ê–ú–ï–† –ï–°–õ–ò –û–ù –ê–ö–¢–ò–í–ï–ù
            if isSpammerActive and currentBestJob then
                lastSpamJob = currentBestJob.jobId
                lastSpamTime = 0  -- –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ç–∞–π–º–µ—Ä
            end
            
            processBestJob()
        end
        task.wait(0.01)
    end
end

-- SPAMMER LOOP
-- SPAMMER LOOP (–ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø)
local function spammerLoop()
    while true do
        if isSpammerActive then
            if lastSpamJob and not isProcessing then
                local currentTime = tick()
                if currentTime - lastSpamTime >= spamCooldown then
                    local targetGui = findHirimiGui()
                    if targetGui then
                        -- –ü—Ä–æ–±—É–µ–º –∑–∞–π—Ç–∏ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —ç—Ç–æ –∞–∫—Ç—É–∞–ª—å–Ω—ã–π JobID
                        if lastSpamJob == (currentBestJob and currentBestJob.jobId) then
                            setJobIDText(targetGui, lastSpamJob)
                            task.wait(0.01)
                            clickJoinButton(targetGui)
                            addLog("üîÑ Spammer: retrying last job")
                        else
                            addLog("üîÑ Spammer: job outdated, waiting for new")
                        end
                        lastSpamTime = tick()
                    end
                end
            end
            task.wait(0.1)
        else
            task.wait(1) -- –ñ–¥–µ–º –ø–æ–¥–æ–ª—å—à–µ –∫–æ–≥–¥–∞ —Å–ø–∞–º–µ—Ä –≤—ã–∫–ª—é—á–µ–Ω
        end
    end
end

-- WebSocket —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
local function connectWebSocket()
    local success, socket = pcall(WebSocket.connect, WebSocketURL)
    if success and socket then
        ws = socket
        connection = ws.OnMessage:Connect(function(msg)
            if not isActive then return end

            local name, money, players, jobId = msg:match("(.+)|(.+)|(.+)|(.+)")
            if name and money and players and jobId then
                local jobData = {
                    name = name,
                    money = money,
                    players = players,
                    jobId = jobId,
                    score = calculateScore(players, money)
                }

                addLog("Added: "..name.." | "..players.." | "..money.."/sec")
                addJob(jobData)
            end
        end)

        ws.OnClose:Connect(function()
            addLog("Disconnected")
        end)
        
        addLog("‚úÖ Connected to server")
    else
        addLog("‚ùå Connection failed")
    end
end

-- –°–æ–∑–¥–∞–Ω–∏–µ UI —Å Discord —Å—Å—ã–ª–∫–æ–π
local function createUI()
    print("[UI] Starting UI creation with retry system...")
    
    local maxAttempts = 5
    local CoreGui = nil
    
    -- –ü–æ–ª—É—á–∞–µ–º CoreGui —Å –ø–æ–≤—Ç–æ—Ä–Ω—ã–º–∏ –ø–æ–ø—ã—Ç–∫–∞–º–∏
    for attempt = 1, maxAttempts do
        print("[UI] Creation attempt " .. attempt .. "/" .. maxAttempts)
        
        local success, result = pcall(function()
            return game:GetService("CoreGui")
        end)
        
        if success and result then
            -- –¢–µ—Å—Ç–∏—Ä—É–µ–º —á—Ç–æ CoreGui –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ —Ä–∞–±–æ—Ç–∞–µ—Ç
            local testSuccess, testError = pcall(function()
                local testGui = Instance.new("ScreenGui")
                testGui.Name = "TestGUI_" .. attempt
                testGui.Parent = result
                
                -- –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ GUI –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –¥–æ–±–∞–≤–∏–ª—Å—è
                local added = result:FindFirstChild("TestGUI_" .. attempt)
                if added then
                    added:Destroy()
                    return true
                else
                    error("Test GUI was not added to CoreGui")
                end
            end)
            
            if testSuccess then
                CoreGui = result
                print("[UI] CoreGui test passed on attempt " .. attempt)
                break
            else
                print("[UI] CoreGui test failed on attempt " .. attempt .. ": " .. (testError or "unknown"))
            end
        else
            print("[UI] Failed to get CoreGui on attempt " .. attempt .. ": " .. (result or "unknown"))
        end
        
        if attempt < maxAttempts then
            wait(1)
        end
    end
    
    if not CoreGui then
        error("[UI] Failed to get working CoreGui after " .. maxAttempts .. " attempts!")
    end

    -- –°–æ–∑–¥–∞–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π UI
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "AUFJoinerUI"
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    
    -- –û–¢–î–ï–õ–¨–ù–ê–Ø Discord —Å—Å—ã–ª–∫–∞ –ë–ï–ó —Ñ–æ–Ω–∞ (–≤ 3 —Ä–∞–∑–∞ –±–æ–ª—å—à–µ)
    local discordScreenGui = Instance.new("ScreenGui")
    discordScreenGui.Name = "AUFJoinerDiscord"
    discordScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    
    discordLabel = Instance.new("TextLabel")
    discordLabel.Name = "DiscordLink"
    discordLabel.Text = "https://discord.gg/T9jXGCKmqw"
    discordLabel.Size = UDim2.new(0, 400, 0, 60)
    discordLabel.Position = UDim2.new(0.5, -200, 0, 5)
    discordLabel.TextColor3 = Color3.fromRGB(88, 101, 242)
    discordLabel.BackgroundTransparency = 1
    discordLabel.Font = Enum.Font.GothamBlack
    discordLabel.TextSize = 20
    discordLabel.TextXAlignment = Enum.TextXAlignment.Center
    discordLabel.TextYAlignment = Enum.TextYAlignment.Center
    discordLabel.TextStrokeTransparency = 0.5
    discordLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    discordLabel.Parent = discordScreenGui

    -- –û—Å–Ω–æ–≤–Ω–æ–µ –º–µ–Ω—é
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "MainFrame"
    mainFrame.Size = UDim2.new(0, 300, 0, 120)
    mainFrame.Position = UDim2.new(0.5, -150, 0, 70)
    mainFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 25)
    mainFrame.BackgroundTransparency = 0.1
    mainFrame.BorderSizePixel = 0
    mainFrame.Active = not isUILocked
    mainFrame.Draggable = not isUILocked

    hopperButton = Instance.new("TextButton")
    hopperButton.Text = "HOPPER"
    hopperButton.Size = UDim2.new(0, 200, 0, 40)
    hopperButton.Position = UDim2.new(0.5, -100, 0, 10)
    hopperButton.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
    hopperButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    hopperButton.Font = Enum.Font.GothamBold
    hopperButton.TextSize = 16

    lockButton = Instance.new("TextButton")
    lockButton.Text = "üîí"
    lockButton.Size = UDim2.new(0, 40, 0, 40)
    lockButton.Position = UDim2.new(1, -45, 0, 10)
    lockButton.BackgroundColor3 = Color3.fromRGB(180, 60, 60)
    lockButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    lockButton.Font = Enum.Font.GothamBold
    lockButton.TextSize = 18

    -- SPAMMER Button (–º–∞–ª–µ–Ω—å–∫–∞—è –∫–Ω–æ–ø–∫–∞ —Ä—è–¥–æ–º —Å –∑–∞–º–æ—á–∫–æ–º)
    spammerButton = Instance.new("TextButton")
    spammerButton.Text = "S"
    spammerButton.Size = UDim2.new(0, 30, 0, 30)
    spammerButton.Position = UDim2.new(1, -80, 0, 15)
    spammerButton.BackgroundColor3 = Color3.fromRGB(70, 70, 90)
    spammerButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    spammerButton.Font = Enum.Font.GothamBold
    spammerButton.TextSize = 14

    logText = Instance.new("TextLabel")
    logText.Text = "Ready to start..."
    logText.Size = UDim2.new(1, -20, 0, 40)
    logText.Position = UDim2.new(0, 10, 0, 60)
    logText.TextColor3 = Color3.fromRGB(220, 220, 220)
    logText.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
    logText.BackgroundTransparency = 0.3
    logText.Font = Enum.Font.GothamMedium
    logText.TextSize = 14
    logText.TextXAlignment = Enum.TextXAlignment.Left
    logText.TextYAlignment = Enum.TextYAlignment.Top
    logText.TextWrapped = true

    -- –î–æ–±–∞–≤–ª—è–µ–º –∑–∞–∫—Ä—É–≥–ª–µ–Ω–∏—è
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 8)
    corner.Parent = mainFrame

    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 6)
    buttonCorner.Parent = hopperButton
    buttonCorner:Clone().Parent = lockButton
    buttonCorner:Clone().Parent = spammerButton

    local logCorner = Instance.new("UICorner")
    logCorner.CornerRadius = UDim.new(0, 6)
    logCorner.Parent = logText

    -- –°–æ–±–∏—Ä–∞–µ–º UI
    hopperButton.Parent = mainFrame
    lockButton.Parent = mainFrame
    spammerButton.Parent = mainFrame
    logText.Parent = mainFrame
    mainFrame.Parent = screenGui
    
    -- –î–æ–±–∞–≤–ª—è–µ–º –æ–±–∞ GUI –≤ CoreGui
    screenGui.Parent = CoreGui
    discordScreenGui.Parent = CoreGui
    
    -- –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ UI –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ —Å–æ–∑–¥–∞–ª—Å—è
    wait(0.1)
    local createdGUI = CoreGui:FindFirstChild("AUFJoinerUI")
    local createdDiscord = CoreGui:FindFirstChild("AUFJoinerDiscord")
    if not createdGUI or not createdDiscord then
        error("[UI] Failed to add ScreenGui to CoreGui!")
    end
    
    print("[UI] ‚úÖ UI created successfully!")
    return screenGui
end

-- ===== –ì–õ–ê–í–ù–´–ô –ó–ê–ü–£–°–ö =====
prints("Loading AUFJoiner system...")

-- –ñ–¥–µ–º –ø–æ–ª–Ω—É—é –∑–∞–≥—Ä—É–∑–∫—É
local CoreGuiReady = waitForFullLoad()

-- –°–æ–∑–¥–∞–µ–º UI —Å —Å–∏—Å—Ç–µ–º–æ–π –ø–æ–≤—Ç–æ—Ä–æ–≤
menuGui = createUI()

-- –ü–æ–¥–∫–ª—é—á–∞–µ–º —Å–æ–±—ã—Ç–∏—è
hopperButton.MouseButton1Click:Connect(function()
    isActive = not isActive
    if isActive then
        hopperButton.Text = "WORKING..."
        hopperButton.BackgroundColor3 = Color3.fromRGB(60, 180, 80)
        addLog("Started hopping...")
        connectWebSocket()
    else
        hopperButton.Text = "HOPPER"
        hopperButton.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
        addLog("Stopped")
        if connection then connection:Disconnect() end
        if ws then ws:Close() end
    end
end)

lockButton.MouseButton1Click:Connect(function()
    isUILocked = not isUILocked
    local mainFrame = menuGui:FindFirstChild("MainFrame")

    if mainFrame then
        if isUILocked then
            lockButton.Text = "üîí"
            lockButton.BackgroundColor3 = Color3.fromRGB(180, 60, 60)
            mainFrame.Active = false
            mainFrame.Draggable = false
            addLog("UI Locked")
        else
            lockButton.Text = "üîì"
            lockButton.BackgroundColor3 = Color3.fromRGB(60, 180, 80)
            mainFrame.Active = true
            mainFrame.Draggable = true
            addLog("UI Unlocked")
        end
    end
end)

-- SPAMMER Button —Å–æ–±—ã—Ç–∏–µ
spammerButton.MouseButton1Click:Connect(function()
    isSpammerActive = not isSpammerActive
    if isSpammerActive then
        spammerButton.BackgroundColor3 = Color3.fromRGB(60, 180, 80)
        addLog("üîÑ Spammer: ON (5s retry)")
    else
        spammerButton.BackgroundColor3 = Color3.fromRGB(70, 70, 90)
        addLog("üîÑ Spammer: OFF (single attempt)")
    end
end)

-- –ó–∞–ø—É—Å–∫–∞–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
spawn(processingLoop)
spawn(spammerLoop)

-- ===== –°–ò–°–¢–ï–ú–ê –û–ß–ò–°–¢–ö–ò –û–®–ò–ë–û–ö =====
local GuiService = cloneref(game:GetService("GuiService"))
task.spawn(function()
    while true do
        GuiService:ClearError()
        task.wait(0.01)
    end
end)

prints("‚úÖ AUFJoiner system loaded successfully!")

